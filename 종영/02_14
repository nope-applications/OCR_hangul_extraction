import cv2
import numpy as np
import time
import math

image_num = 16


# 컨투어 찾기
def findContour(image):
    # 글자의 외각만 찾기, 좌표들은 contours에 들어있음
    contours, hierarchy = cv2.findContours(image, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    # 컨투어 반환
    return contours, hierarchy


# 종(0)켈레톤
def skeletonize(img):
    # ret, img = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY_INV)
    th, img = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)
    # img = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
    #                             cv2.THRESH_BINARY_INV, 15, 50)
    skel = img.copy()

    skel[:, :] = 0
    kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (3, 3))

    while True:
        eroded = cv2.morphologyEx(img, cv2.MORPH_ERODE, kernel)
        temp = cv2.morphologyEx(eroded, cv2.MORPH_DILATE, kernel)
        temp = cv2.subtract(img, temp)
        skel = cv2.bitwise_or(skel, temp)
        img[:, :] = eroded[:, :]
        if cv2.countNonZero(img) == 0:
            break
    return skel


def hsvEqualized(hsv_image):
    h, s, v = cv2.split(hsv_image)

    # h,s,v값을 히스토그램 평활화
    equalizedH = cv2.equalizeHist(h)
    equalizedS = cv2.equalizeHist(s)
    equalizedV = cv2.equalizeHist(v)

    # h,s,v,를 각각 평활화 작업후 를 합쳐서 새로운 hsv 이미지를 만듦.
    new_hsv_image = cv2.merge([equalizedH, equalizedS, equalizedV])

    # hsv -> bgr
    new_hsv_image = cv2.cvtColor(new_hsv_image, cv2.COLOR_HSV2BGR)
    return new_hsv_image


# 색의 개수 만큼 검은색 이미지를 만든다.
def createBlackImage(image):
    start_time = time.time()

    print('검은색 이미지 ' + str(image_num) + '개 만들기 시작')

    draw_image_list = []

    for i in range(0, image_num):
        black_image = np.zeros_like(image)
        draw_image_list.append(black_image)

    print('검은색 이미지 만들기 끝 : ', time.time() - start_time, '\n')

    return draw_image_list


# 검은색 이미지위에 뽑아낸 색 그리기
def blackImageDraw(x_y_line_image, black_image_list):
    start_time = time.time()
    print('검은색 이미지 위에 색 그리기 시작')
    h, w = x_y_line_image.shape
    cv2.imshow("aaaaaa",x_y_line_image)
    rangee = int(256 / image_num)
    for i in range(0, image_num):
        for j in range(i * rangee, (i + 1) * rangee):
            print(j)
            pts=np.where(x_y_line_image==j)
            black_image_list[i][pts[0], pts[1]] = 255
        # 가로로 늘리기

        #팽창후 침식
        # kernel = np.ones((3, 8), np.uint8)
        # black_image_list[i] = cv2.morphologyEx(black_image_list[i], cv2.MORPH_CLOSE, kernel, iterations=1)
        #침식
        # kernel = np.ones((2, 2), np.uint8)
        # black_image_list[i]=cv2.erode(black_image_list[i],kernel,iterations=1)
        # 침식 : 잡음 제거
        # kernel = np.ones((3, 3), np.uint8)
        # black_image_list[i] = cv2.morphologyEx(black_image_list[i], cv2.MORPH_CLOSE, kernel, iterations=1)
        # 침식
        # kernel = np.ones((2, 2), np.uint8)
        # black_image_list[i] = cv2.erode(black_image_list[i], kernel, iterations=1)

        # kernel=np.ones((2,2),np.uint8)

            # black_image_list[i]=skeletonize(black_image_list[i])
        # 팽 침
        # black_image_list[i] = cv2.morphologyEx(black_image_list[i], cv2.MORPH_CLOSE, kernel, iterations=1)

        # 침 팽
        # black_image_list[i] = cv2.morphologyEx(black_image_list[i], cv2.MORPH_OPEN, kernel, iterations=1)
        # black_image_list[i]=skeletonize(black_image_list[i])
            # print(i * rangee, (i + 1) * rangee, j)
        print("")
    # devide_range = math.ceil(255 / image_num)
    #
    # for index, image in enumerate(black_image_list):
    #     pts = np.where(
    #         (x_y_line_image >= 0 + (devide_range * (index))) & (x_y_line_image < (devide_range * (index + 1))))
    #     print(0 + (devide_range * (index)), 0 + (devide_range * (index + 1)))
    #     black_image_list[index][pts[0], pts[1]] = 255
        cv2.imshow('black' + str(i), black_image_list[i])
    print('검은색 이미지 위에 색 그리기 끝 : ', time.time() - start_time, '\n')

    return black_image_list


# 시간체크 시작
start_time = time.time()

# 이미지 경로
image_path = '../image/86.jpg'
# image_path = 'a.png'

# bgr 이미지 불러오기
bgr_image = cv2.imread(image_path)
test_image = cv2.imread(image_path)

cv2.imshow('bgr_image', bgr_image)

hsv_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2HSV)
new_bgr_image = hsvEqualized(hsv_image)

# bgr -> gray 변환
gray_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2GRAY)

cv2.imshow("gray",gray_image)
# 가로선 추출
x_line_image = cv2.Sobel(gray_image, cv2.CV_64F, 0, 1, ksize=1)
x_line_image = np.absolute(x_line_image)
x_line_image = np.uint8(x_line_image)
cv2.imshow('x_line_image', x_line_image)

# 세로선 추출
y_line_image = cv2.Sobel(gray_image, cv2.CV_64F, 1, 0, ksize=1)
y_line_image = np.absolute(y_line_image)
y_line_image = np.uint8(y_line_image)
cv2.imshow('y_line_image', y_line_image)

# 가로 세로 합친 이미지 보여주기
bgr_x_line_add_y_line_image = cv2.bitwise_or(x_line_image, y_line_image)
cv2.imshow('bgr_x_line_add_y_line_image', bgr_x_line_add_y_line_image)

black_image_list = createBlackImage(bgr_x_line_add_y_line_image)

draw_image_list = blackImageDraw(bgr_x_line_add_y_line_image, black_image_list)

count=0
for i in draw_image_list:
    c,h=findContour(i)
    for index,j in enumerate(c) :
        x, y, w, h = cv2.boundingRect(j)

        cv2.rectangle(test_image, (x, y), (x + w, y + h), (0, 0, 255), 1)
        count=count+1
print(count)
cv2.imshow("qqqqqQ",test_image)
cv2.waitKey(0)


# 종영 스켈레톤 적용 - 스켈레톤화된 이미지 반환함.
skel_image = skeletonize(bgr_x_line_add_y_line_image)
cv2.imshow('skel_image', skel_image)

# 컨투어 찾기
contour, hierarchy = findContour(skel_image)

# 네모영역 그리기
count=0
for i, con in enumerate(contour):
    x, y, w, h = cv2.boundingRect(con)

    cv2.rectangle(bgr_image, (x, y), (x + w, y + h), (0, 0, 255), 1)
    count=count+1
    # cv2.circle(bgr_image, (int((x + x + w) / 2), int((y + y + h) / 2)), 1, (0, 0, 255), 1)
    # crop_image = new_bgr_image[y:y + h + 1, x:x + w + 1]
    # cv2.imwrite('../resultFolder/' + str(i) + '_crop.jpg', crop_image)

print(count)
# 최종이미지 출력
cv2.imshow('result', bgr_image)

# 시간측정 끝
print("time : ", time.time() - start_time)
cv2.waitKey(0)
